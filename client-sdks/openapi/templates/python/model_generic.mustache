from __future__ import annotations
import pprint
import re  # noqa: F401
import json

{{#vendorExtensions.x-py-other-imports}}
{{{.}}}
{{/vendorExtensions.x-py-other-imports}}
{{#vendorExtensions.x-py-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-model-imports}}
from typing import Any, ClassVar
from typing_extensions import Self

{{#hasChildren}}
{{#discriminator}}
{{! If this model is a super class, importlib is used. So import the necessary modules for the type here. }}
from typing import TYPE_CHECKING
if TYPE_CHECKING:
{{#mappedModels}}
    from {{packageName}}.models.{{model.classFilename}} import {{modelName}}
{{/mappedModels}}

{{/discriminator}}
{{/hasChildren}}
class {{classname}}({{#parent}}{{{.}}}{{/parent}}{{^parent}}BaseModel{{/parent}}):
    """
    {{#description}}{{{description}}}{{/description}}{{^description}}{{{classname}}}{{/description}}
    """ # noqa: E501
{{#vars}}
    {{name}}: {{{vendorExtensions.x-py-typing}}}
{{/vars}}
{{#isAdditionalPropertiesTrue}}
    additional_properties: dict[str, Any] = {}
{{/isAdditionalPropertiesTrue}}
    __properties: ClassVar[list[str]] = [{{#allVars}}"{{baseName}}"{{^-last}}, {{/-last}}{{/allVars}}]
{{#vars}}
    {{#vendorExtensions.x-regex}}

    @field_validator('{{{name}}}')
    def {{{name}}}_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        {{^required}}
        if value is None:
            return value

        {{/required}}
        {{#required}}
        {{#isNullable}}
        if value is None:
            return value

        {{/isNullable}}
        {{/required}}
        if not re.match(r"{{{.}}}", value{{#vendorExtensions.x-modifiers}} ,re.{{{.}}}{{/vendorExtensions.x-modifiers}}):
            raise ValueError(r"must validate the regular expression {{{vendorExtensions.x-pattern}}}")
        return value
    {{/vendorExtensions.x-regex}}
    {{#isEnum}}

    @field_validator('{{{name}}}')
    def {{{name}}}_validate_enum(cls, value):
        """Validates the enum"""
        {{^required}}
        if value is None:
            return value

        {{/required}}
        {{#required}}
        {{#isNullable}}
        if value is None:
            return value

        {{/isNullable}}
        {{/required}}
        {{#isContainer}}
        {{#isArray}}
        for i in value:
            if i not in set([{{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]):
                raise ValueError("each list item must be one of ({{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}})")
        {{/isArray}}
        {{#isMap}}
        for i in value.values():
            if i not in set([{{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]):
                raise ValueError("dict values must be one of enum values ({{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}})")
        {{/isMap}}
        {{/isContainer}}
        {{^isContainer}}
        if value not in set([{{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]):
            raise ValueError("must be one of enum values ({{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}})")
        {{/isContainer}}
        return value
    {{/isEnum}}
{{/vars}}

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


{{#vendorExtensions.x-has-output-text}}
    @property
    def output_text(self) -> str:
        """Extract text content from output messages.

        This property iterates through the output list and extracts text from
        message content parts, concatenating them together.

        Returns:
            str: Concatenated text from all output messages, or empty string if no output field exists
        """
        # Check if this model has an output field
        if not hasattr(self, 'output') or not self.output:
            return ""

        text_parts = []
        for item in self.output:
            # Handle oneOf wrapper - get actual_instance if it exists
            actual_item = getattr(item, 'actual_instance', item)

            # Check if this is a message type with content
            if hasattr(actual_item, 'content'):
                content = actual_item.content
                # Handle oneOf wrapper for content
                actual_content = getattr(content, 'actual_instance', content)

                # If content is a string, use it directly
                if isinstance(actual_content, str):
                    text_parts.append(actual_content)
                # If content is a list, iterate through parts
                elif isinstance(actual_content, list):
                    for content_part in actual_content:
                        # Handle oneOf wrapper for content part
                        actual_part = getattr(content_part, 'actual_instance', content_part)
                        # Extract text if this part has a text attribute
                        if hasattr(actual_part, 'text'):
                            text_parts.append(actual_part.text)

        return "".join(text_parts)

{{/vendorExtensions.x-has-output-text}}

    def __getattribute__(self, name):
        """Override to automatically unwrap OneOf/AnyOf instances."""
        value = super().__getattribute__(name)

        # Unwrap OneOf/AnyOf wrappers directly
        if hasattr(value, 'actual_instance') and value.actual_instance is not None:
            return value.actual_instance

        # If the value is a dict, unwrap any OneOf instances in its values
        if isinstance(value, dict):
            unwrapped = {}
            for k, v in value.items():
                # Check if this is a OneOf wrapper with actual_instance
                if hasattr(v, 'actual_instance') and v.actual_instance is not None:
                    unwrapped[k] = v.actual_instance
                else:
                    unwrapped[k] = v
            return unwrapped

        return value

{{#vars}}{{#datatype}}{{#isArray}}{{#-first}}
    # Make this model iterable/indexable to access the {{name}} field directly
    # This allows: for item in response: ... and response[0]
    def __iter__(self):
        """Iterate over items in the {{name}} field"""
        return iter(self.{{name}} if self.{{name}} is not None else [])

    def __getitem__(self, index):
        """Get item by index from the {{name}} field"""
        if self.{{name}} is None:
            raise IndexError("list index out of range")
        return self.{{name}}[index]

    def __len__(self):
        """Get length of the {{name}} field"""
        return len(self.{{name}}) if self.{{name}} is not None else 0

{{/-first}}{{/isArray}}{{/datatype}}{{/vars}}

{{#hasChildren}}
{{#discriminator}}
    # JSON field name that stores the object type
    __discriminator_property_name: ClassVar[str] = '{{discriminator.propertyBaseName}}'

    # discriminator mappings
    __discriminator_value_class_map: ClassVar[dict[str, str]] = {
        {{#mappedModels}}'{{{mappingName}}}': '{{{modelName}}}'{{^-last}},{{/-last}}{{/mappedModels}}
    }

    @classmethod
    def get_discriminator_value(cls, obj: dict[str, Any]) -> str | None:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

{{/discriminator}}
{{/hasChildren}}
    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> {{^hasChildren}}Self{{/hasChildren}}{{#hasChildren}}{{#discriminator}}{{#mappedModels}}{{{modelName}}}{{^-last}} | {{/-last}}{{/mappedModels}}{{/discriminator}}{{^discriminator}}Self{{/discriminator}}{{/hasChildren}} | None:
        """Create an instance of {{{classname}}} from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        {{#vendorExtensions.x-py-readonly}}
        * OpenAPI `readOnly` fields are excluded.
        {{/vendorExtensions.x-py-readonly}}
        {{#isAdditionalPropertiesTrue}}
        * Fields in `self.additional_properties` are added to the output dict.
        {{/isAdditionalPropertiesTrue}}
        """
        excluded_fields: set[str] = set([
            {{#vendorExtensions.x-py-readonly}}
            "{{{.}}}",
            {{/vendorExtensions.x-py-readonly}}
            {{#isAdditionalPropertiesTrue}}
            "additional_properties",
            {{/isAdditionalPropertiesTrue}}
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        {{#allVars}}
        {{#isContainer}}
        {{#isArray}}
        {{#items.isArray}}
        {{^items.items.isPrimitiveType}}
        # override the default output from pydantic by calling `to_dict()` of each item in {{{name}}} (list of list)
        _items = []
        if self.{{{name}}}:
            for _item_{{{name}}} in self.{{{name}}}:
                if _item_{{{name}}}:
                    _items.append(
                         [_inner_item.to_dict() if hasattr(_inner_item, 'to_dict') else _inner_item for _inner_item in _item_{{{name}}} if _inner_item is not None]
                    )
            _dict['{{{baseName}}}'] = _items
        {{/items.items.isPrimitiveType}}
        {{/items.isArray}}
        {{^items.isArray}}
        {{^items.isPrimitiveType}}
        {{^items.isEnumOrRef}}
        # override the default output from pydantic by calling `to_dict()` of each item in {{{name}}} (list)
        _items = []
        if self.{{{name}}}:
            for _item_{{{name}}} in self.{{{name}}}:
                if _item_{{{name}}}:
                    if hasattr(_item_{{{name}}}, 'to_dict'):
                        _items.append(_item_{{{name}}}.to_dict())
                    else:
                        _items.append(_item_{{{name}}})
            _dict['{{{baseName}}}'] = _items
        {{/items.isEnumOrRef}}
        {{/items.isPrimitiveType}}
        {{/items.isArray}}
        {{/isArray}}
        {{#isMap}}
        {{#items.isArray}}
        {{^items.items.isPrimitiveType}}
        # override the default output from pydantic by calling `to_dict()` of each value in {{{name}}} (dict of array)
        _field_dict_of_array = {}
        if self.{{{name}}}:
            for _key_{{{name}}} in self.{{{name}}}:
                if self.{{{name}}}[_key_{{{name}}}] is not None:
                    _field_dict_of_array[_key_{{{name}}}] = [
                        _item.to_dict() if hasattr(_item, 'to_dict') else _item for _item in self.{{{name}}}[_key_{{{name}}}]
                    ]
            _dict['{{{baseName}}}'] = _field_dict_of_array
        {{/items.items.isPrimitiveType}}
        {{/items.isArray}}
        {{^items.isArray}}
        {{^items.isPrimitiveType}}
        {{^items.isEnumOrRef}}
        # override the default output from pydantic by calling `to_dict()` of each value in {{{name}}} (dict)
        _field_dict = {}
        if self.{{{name}}}:
            for _key_{{{name}}} in self.{{{name}}}:
                _val = self.{{{name}}}[_key_{{{name}}}]
                if _val is None:
                    _field_dict[_key_{{{name}}}] = None
                elif hasattr(_val, 'to_dict'):
                    _field_dict[_key_{{{name}}}] = _val.to_dict()
                else:
                    _field_dict[_key_{{{name}}}] = _val
            _dict['{{{baseName}}}'] = _field_dict
        {{/items.isEnumOrRef}}
        {{/items.isPrimitiveType}}
        {{/items.isArray}}
        {{/isMap}}
        {{/isContainer}}
        {{^isContainer}}
        {{^isPrimitiveType}}
        {{^isEnumOrRef}}
        # override the default output from pydantic by calling `to_dict()` of {{{name}}}
        if self.{{{name}}}:
            if hasattr(self.{{{name}}}, 'to_dict'):
                _dict_value = self.{{{name}}}.to_dict()
                # Only include if to_dict() returns a non-None value (handles oneOf wrappers with actual_instance=None)
                if _dict_value is not None:
                    _dict['{{{baseName}}}'] = _dict_value
                elif '{{{baseName}}}' in _dict:
                    # Remove from dict if to_dict() returned None (oneOf wrapper with no actual instance)
                    del _dict['{{{baseName}}}']
            else:
                _dict['{{{baseName}}}'] = self.{{{name}}}
        {{/isEnumOrRef}}
        {{/isPrimitiveType}}
        {{/isContainer}}
        {{/allVars}}
        {{#isAdditionalPropertiesTrue}}
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        {{/isAdditionalPropertiesTrue}}
        {{#allVars}}
        {{#isNullable}}
        # set to None if {{{name}}} (nullable) is None
        # and model_fields_set contains the field
        if self.{{name}} is None and "{{{name}}}" in self.model_fields_set:
            _dict['{{{baseName}}}'] = None

        {{/isNullable}}
        {{/allVars}}
        return _dict

    {{#hasChildren}}
    @classmethod
    def from_dict(cls, obj: dict[str, Any]) -> {{#discriminator}}{{#mappedModels}}{{{modelName}}}{{^-last}} | {{/-last}}{{/mappedModels}}{{/discriminator}}{{^discriminator}}Self{{/discriminator}} | None:
        """Create an instance of {{{classname}}} from a dict"""
        {{#discriminator}}
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        {{#mappedModels}}
        if object_type ==  '{{{modelName}}}':
            return import_module("{{packageName}}.models.{{model.classFilename}}").{{modelName}}.from_dict(obj)
        {{/mappedModels}}

        raise ValueError("{{{classname}}} failed to lookup discriminator value from " +
                            json.dumps(obj) + ". Discriminator property name: " + cls.__discriminator_property_name +
                            ", mapping: " + json.dumps(cls.__discriminator_value_class_map))
        {{/discriminator}}
    {{/hasChildren}}
    {{^hasChildren}}
    @classmethod
    def from_dict(cls, obj: dict[str, Any] | None) -> Self | None:
        """Create an instance of {{{classname}}} from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        {{#disallowAdditionalPropertiesIfNotPresent}}
        {{^isAdditionalPropertiesTrue}}
        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in {{classname}}) in the input: " + _key)

        {{/isAdditionalPropertiesTrue}}
        {{/disallowAdditionalPropertiesIfNotPresent}}
        _obj = cls.model_validate({
            k: v for k, v in {
            {{#allVars}}
            {{#isContainer}}
            {{#isArray}}
            {{#items.isArray}}
            {{#items.items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"),
            {{/items.items.isPrimitiveType}}
            {{^items.items.isPrimitiveType}}
            "{{{baseName}}}": [
                    [{{{items.items.dataType}}}.from_dict(_inner_item) for _inner_item in _item]
                    for _item in obj["{{{baseName}}}"]
                ] if obj.get("{{{baseName}}}") is not None else None,
            {{/items.items.isPrimitiveType}}
            {{/items.isArray}}
            {{^items.isArray}}
            {{^items.isPrimitiveType}}
            {{#items.isEnumOrRef}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"),
            {{/items.isEnumOrRef}}
            {{^items.isEnumOrRef}}
            {{#items.isMap}}
            {{#items.items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"),
            {{/items.items.isPrimitiveType}}
            {{^items.items.isPrimitiveType}}
            "{{{baseName}}}": [
                dict((_k, {{{items.items.dataType}}}.from_dict(_v)) for _k, _v in _item.items())
                for _item in obj["{{{baseName}}}"]
            ] if obj.get("{{{baseName}}}") is not None else None,
            {{/items.items.isPrimitiveType}}
            {{/items.isMap}}
            {{^items.isMap}}
            "{{{baseName}}}": [{{{items.dataType}}}.from_dict(_item) for _item in obj["{{{baseName}}}"]] if obj.get("{{{baseName}}}") is not None else None,
            {{/items.isMap}}
            {{/items.isEnumOrRef}}
            {{/items.isPrimitiveType}}
            {{#items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"),
            {{/items.isPrimitiveType}}
            {{/items.isArray}}
            {{/isArray}}
            {{#isMap}}
            {{^items.isPrimitiveType}}
            {{^items.isEnumOrRef}}
            {{#items.isContainer}}
            {{#items.isMap}}
            "{{{baseName}}}": dict(
                (_k, dict(
                    (_ik, {{{items.items.dataType}}}.from_dict(_iv))
                        for _ik, _iv in _v.items()
                    )
                    if _v is not None
                    else None
                )
                for _k, _v in obj.get("{{{baseName}}}").items()
            )
            if obj.get("{{{baseName}}}") is not None
            else None,
            {{/items.isMap}}
            {{#items.isArray}}
            "{{{baseName}}}": dict(
                (_k,
                        [{{{items.items.dataType}}}.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("{{{baseName}}}", {}).items()
            ),
            {{/items.isArray}}
            {{/items.isContainer}}
            {{^items.isContainer}}
            "{{{baseName}}}": dict(
                (_k, {{{items.dataType}}}.from_dict(_v))
                for _k, _v in obj["{{{baseName}}}"].items()
            )
            if obj.get("{{{baseName}}}") is not None
            else None,
            {{/items.isContainer}}
            {{/items.isEnumOrRef}}
            {{#items.isEnumOrRef}}
            "{{{baseName}}}": dict((_k, _v) for _k, _v in obj.get("{{{baseName}}}").items()) if obj.get("{{{baseName}}}") is not None else None,
            {{/items.isEnumOrRef}}
            {{/items.isPrimitiveType}}
            {{#items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"),
            {{/items.isPrimitiveType}}
            {{/isMap}}
            {{/isContainer}}
            {{^isContainer}}
            {{^isPrimitiveType}}
            {{^isEnumOrRef}}
            "{{{baseName}}}": {{{dataType}}}.from_dict(obj["{{{baseName}}}"]) if obj.get("{{{baseName}}}") is not None else None,
            {{/isEnumOrRef}}
            {{#isEnumOrRef}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{#defaultValue}} if obj.get("{{baseName}}") is not None else {{{defaultValue}}}{{/defaultValue}},
            {{/isEnumOrRef}}
            {{/isPrimitiveType}}
            {{#isPrimitiveType}}
            {{#defaultValue}}
            "{{{baseName}}}": obj.get("{{{baseName}}}") if obj.get("{{{baseName}}}") is not None else {{{defaultValue}}},
            {{/defaultValue}}
            {{^defaultValue}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"),
            {{/defaultValue}}
            {{/isPrimitiveType}}
            {{/isContainer}}
            {{/allVars}}
            }.items() if k in obj
        })
        {{#isAdditionalPropertiesTrue}}
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        {{/isAdditionalPropertiesTrue}}
        return _obj
    {{/hasChildren}}

{{#vendorExtensions.x-py-postponed-model-imports.size}}
{{#vendorExtensions.x-py-postponed-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-postponed-model-imports}}
# TODO: Rewrite to not use raise_errors
{{classname}}.model_rebuild(raise_errors=False)
{{/vendorExtensions.x-py-postponed-model-imports.size}}
